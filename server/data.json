{"courses" :
    [
    {
      "courseTitle": "Introduction to Python Programming",
      "difficulty": "Beginner",
      "description": "This course provides a comprehensive introduction to Python, a versatile and beginner-friendly programming language. Learners will start with the fundamental concepts of programming, including data types, variables, and control flow. The course will then progress to more advanced topics such as functions, data structures, and object-oriented programming. The goal is to equip students with a solid foundation to write clear, efficient, and well-structured Python code for a wide range of applications.",
      "chapters": [
        {
          "chapterNumber": 1,
          "chapterTitle": "Python Fundamentals: Syntax and Data Types",
          "subtopics": [
            {
              "subtopicTitle": "Introduction to Python and Its Syntax",
              "explanation": "Python is a high-level, interpreted programming language known for its readability and simplicity. Its syntax is designed to be clear and intuitive, using English keywords and fewer punctuation marks than many other languages. This makes it an excellent choice for beginners. One of the most distinctive features of Python is its use of indentation to define code blocks, such as loops, functions, and conditional statements, instead of braces or other symbols. This forces a clean and consistent coding style. A basic Python program, often called 'Hello, World!', is a single line of code: `print('Hello, World!')`. Unlike languages like C++ or Java, you don't need a main function or class definition for this simple program. Python code is executed by an interpreter, which reads and executes the code line by line. This process allows for quick testing and debugging. Python supports various programming paradigms, including procedural, object-oriented, and functional programming. It has a vast standard library that provides modules and functions for a wide range of tasks, from web development to data analysis. The language is also cross-platform, meaning the same code can run on different operating systems like Windows, macOS, and Linux without modification. This combination of simplicity, versatility, and a strong community makes Python one of the most popular programming languages in the world, used by companies like Google, Netflix, and NASA.",
              "examples": [
                "A simple print statement: `print('Welcome to Python!')`",
                "An if-else statement with indentation: `if x > 5: \n    print('x is greater than 5') \nelse: \n    print('x is not greater than 5')`"
              ]
            },
            {
              "subtopicTitle": "Variables and Basic Data Types",
              "explanation": "In Python, a **variable** is a named storage location that holds a value. Variables are created the moment you first assign a value to them. Python is dynamically typed, meaning you don't need to declare the variable type explicitly. The interpreter infers the type from the value assigned. For example, `age = 30` creates an integer variable, and `name = 'Alice'` creates a string variable. Python has several built-in **data types** to store different kinds of data. **Numbers** include `int` (integers, e.g., 5), `float` (floating-point numbers, e.g., 5.0), and `complex` numbers. **Strings** (`str`) are sequences of characters enclosed in single or double quotes, e.g., `'hello'` or `\"Python\"`. Strings are immutable, meaning their content cannot be changed after creation. You can perform various operations on strings, such as concatenation (`'Hello' + ' ' + 'World'`) and slicing. **Booleans** (`bool`) represent one of two values: `True` or `False`, and are used for logical operations. You can also have special values like `None`, which represents the absence of a value. Understanding these basic data types is fundamental to writing any program, as they are the building blocks of all data manipulation. Python's dynamic typing and straightforward variable assignment make it very easy to get started, but it also requires a developer to be mindful of the data types they are working with to avoid errors.",
              "examples": [
                "Creating an integer variable: `x = 10`",
                "Creating a string variable: `greeting = 'Hello'`",
                "Checking the type of a variable: `type(x)` would return `<class 'int'>`"
              ]
            },
            {
              "subtopicTitle": "Working with Operators and Expressions",
              "explanation": "Operators are special symbols that perform operations on values and variables. Python provides a rich set of operators, which are categorized into different types. **Arithmetic operators** are used for mathematical calculations: `+` (addition), `-` (subtraction), `*` (multiplication), `/` (division), `//` (floor division), `%` (modulo), and `**` (exponentiation). For example, `10 + 5` results in `15`, and `10 / 3` results in `3.333...`, while `10 // 3` results in `3`. **Comparison operators** are used to compare two values and return a Boolean result (`True` or `False`): `==` (equal to), `!=` (not equal to), `>` (greater than), `<` (less than), `>=` (greater than or equal to), and `<=` (less than or equal to). For instance, `5 > 3` evaluates to `True`. **Logical operators** (`and`, `or`, `not`) are used to combine conditional statements. `(x > 5) and (y < 10)` is a single expression that is `True` only if both conditions are met. **Assignment operators** (`=`, `+=`, `-=`, etc.) are used to assign values to variables. `x += 5` is a shorthand for `x = x + 5`. An **expression** is a combination of values, variables, operators, and function calls that the Python interpreter evaluates to a single value. Understanding operator precedence (the order in which operations are performed) is crucial for writing correct expressions. For example, in `2 + 3 * 4`, the multiplication is performed before the addition, resulting in `14`. Parentheses `()` can be used to override this order. Mastering operators and expressions is a fundamental skill for building any program, as they are the tools used to perform calculations and make decisions within the code.",
              "examples": [
                "Using arithmetic operators: `result = 25 * 4 / 2` (result is 50.0)",
                "Using comparison and logical operators: `is_adult = (age >= 18) and (has_id == True)`"
              ]
            }
          ],
          "chapterSummary": "Chapter 1 introduced the foundational concepts of Python programming. We began with an overview of Python's simple, indentation-based syntax and its role as a beginner-friendly, interpreted language. We then explored the essential concepts of variables and basic data types, including numbers, strings, and booleans, which are the building blocks for all data in Python. Finally, we covered the various types of operators and expressions used for performing calculations and making logical comparisons, a key step in controlling program behavior.",
          "quiz": [
            {
              "question": "Which of the following is a key feature of Python's syntax?",
              "options": [
                "Use of semicolons to end statements",
                "Strict requirement for braces to define code blocks",
                "Use of indentation to define code blocks",
                "Mandatory declaration of variable types"
              ],
              "type": "mcq",
              "answer": "Use of indentation to define code blocks"
            },
            {
              "question": "What is the data type for the value 'Hello, World!'?",
              "type": "one-word",
              "answer": "String"
            },
            {
              "question": "In Python, what is the value `True`'s data type?",
              "type": "one-word",
              "answer": "Boolean"
            },
            {
              "question": "Which operator is used for exponentiation?",
              "options": [
                "/",
                "%",
                "**",
                "//"
              ],
              "type": "mcq",
              "answer": "**"
            },
            {
              "question": "What is the result of the expression `10 // 3`?",
              "type": "one-word",
              "answer": "3"
            },
            {
              "question": "What is the primary purpose of a variable in programming?",
              "type": "one-word",
              "answer": "Storage"
            },
            {
              "question": "Which operator means 'not equal to'?",
              "options": [
                "==",
                "=",
                "!= ",
                "<>"
              ],
              "type": "mcq",
              "answer": "!="
            },
            {
              "question": "An expression combines values, variables, and what else?",
              "type": "one-word",
              "answer": "Operators"
            },
            {
              "question": "What does Python use to define code blocks?",
              "type": "one-word",
              "answer": "Indentation"
            },
            {
              "question": "Which of these is not a number data type in Python?",
              "options": [
                "int",
                "float",
                "double",
                "complex"
              ],
              "type": "mcq",
              "answer": "double"
            }
          ]
        },
        {
          "chapterNumber": 2,
          "chapterTitle": "Control Flow and Data Structures",
          "subtopics": [
            {
              "subtopicTitle": "Conditional Statements: `if`, `elif`, `else`",
              "explanation": "In programming, **control flow** refers to the order in which statements are executed. One of the most fundamental ways to control program flow is through **conditional statements**, which allow a program to make decisions and execute different code blocks based on whether a condition is true or false. In Python, the primary conditional statement is the `if` statement. The basic syntax is `if condition: code_block`. If the condition evaluates to `True`, the indented code block is executed. If it's `False`, the code block is skipped. You can extend this logic with the `else` statement, which provides an alternative code block to be executed when the `if` condition is `False`. The syntax becomes `if condition: code_block_if_true else: code_block_if_false`. For situations with multiple possible conditions, Python offers the `elif` (short for 'else if') statement. This allows you to check a series of conditions in order. The first `elif` condition that evaluates to `True` will have its corresponding code block executed, and the rest will be skipped. You can have any number of `elif` clauses. The full structure looks like this: `if condition1: ... elif condition2: ... else: ...`. It is important to remember that only one of these blocks will ever be executed. The `if` statement is a cornerstone of programming logic, enabling programs to react dynamically to different inputs and states. The indentation-based structure ensures that the code's logic is visually clear and easy to follow. Mastery of conditional statements is essential for building any program that requires decision-making capabilities, from simple user input validation to complex algorithms.",
              "examples": [
                "Simple `if` statement: `if score >= 90: \n    print('You got an A!')`",
                "Using `if`, `elif`, and `else`: `if age < 13: \n    print('Child') \nelif age < 20: \n    print('Teenager') \nelse: \n    print('Adult')`"
              ]
            },
            {
              "subtopicTitle": "Loops: `for` and `while`",
              "explanation": "Loops are another crucial aspect of control flow, allowing a program to repeat a block of code multiple times. Python has two main types of loops: `for` loops and `while` loops. The **`for` loop** is used to iterate over a sequence (such as a list, tuple, dictionary, or string) or any other iterable object. The syntax is `for item in sequence: code_block`. The `for` loop will execute the code block once for each item in the sequence. For example, `for number in [1, 2, 3]: print(number)` would print `1`, then `2`, then `3`. A common use of the `for` loop is with the `range()` function, which generates a sequence of numbers, like `for i in range(5): print(i)` which prints numbers from 0 to 4. The **`while` loop** is used to execute a block of code as long as a certain condition is `True`. The syntax is `while condition: code_block`. The loop will continue to run until the condition becomes `False`. It's important to ensure that the condition will eventually become `False` to avoid an **infinite loop**. For example, a `while` loop can be used to process user input until a specific keyword is entered. Both loops can be controlled using `break` and `continue` statements. The **`break`** statement exits the loop entirely, while the **`continue`** statement skips the current iteration and moves to the next one. Understanding which type of loop to use is key: a `for` loop is typically used when you know the number of iterations in advance or are iterating over a fixed collection, while a `while` loop is used when the number of iterations is not known beforehand, and the loop depends on a specific condition being met. ",
              "examples": [
                "A `for` loop over a list: `fruits = ['apple', 'banana']; for fruit in fruits: print(fruit)`",
                "A `while` loop that counts to 5: `count = 0; while count < 5: \n    print(count) \n    count += 1`"
              ]
            },
            {
              "subtopicTitle": "Core Data Structures: Lists, Tuples, Dictionaries, and Sets",
              "explanation": "Beyond the basic data types, Python provides several built-in **data structures** for organizing and storing collections of data. A **list** is an ordered, mutable collection of items. Lists are created using square brackets `[]`, and items can be of different data types. For example, `my_list = [1, 'hello', 3.14]`. Lists are highly flexible, allowing you to add, remove, and modify elements. A **tuple** is similar to a list but is **immutable**, meaning its contents cannot be changed after creation. Tuples are created using parentheses `()`, e.g., `my_tuple = (1, 2, 'three')`. Their immutability makes them useful for data that should not be altered, and they can be slightly more efficient than lists. A **dictionary** is an unordered collection of key-value pairs. Dictionaries are created using curly braces `{}` and are highly optimized for retrieving data based on a key. For example, `person = {'name': 'Alice', 'age': 30}`. You access values using their keys, like `person['name']`. A **set** is an unordered collection of unique elements. Sets are useful for tasks involving membership testing and eliminating duplicate entries. They are also created using curly braces `{}` but contain single values, not key-value pairs, e.g., `my_set = {1, 2, 3}`. The ability to choose the right data structure for a given task is a crucial skill for any Python programmer, as each one has its own strengths and weaknesses. Mastering these four core data structures is a significant step toward writing more powerful and efficient programs.",
              "examples": [
                "A list of numbers: `numbers = [10, 20, 30]`",
                "A dictionary with a person's information: `user = {'id': 1, 'username': 'Pythonista'}`"
              ]
            }
          ],
          "chapterSummary": "Chapter 2 explored the foundational concepts of control flow and core data structures. We learned about conditional statements like `if`, `elif`, and `else` for making decisions in our code. We then covered loops, including the `for` loop for iterating over sequences and the `while` loop for repeating code based on a condition. Finally, we were introduced to Python's essential data structures: lists (mutable sequences), tuples (immutable sequences), dictionaries (key-value pairs), and sets (unique, unordered elements), understanding when to use each for effective data management.",
          "quiz": [
            {
              "question": "Which keyword is used to provide an alternative code block in an `if` statement?",
              "type": "one-word",
              "answer": "else"
            },
            {
              "question": "What type of loop is used to iterate over a sequence of items?",
              "type": "one-word",
              "answer": "for"
            },
            {
              "question": "Which data structure is an ordered, mutable collection of items?",
              "type": "one-word",
              "answer": "List"
            },
            {
              "question": "Which keyword is used to handle multiple conditions in an `if` statement?",
              "options": [
                "else",
                "elif",
                "then",
                "while"
              ],
              "type": "mcq",
              "answer": "elif"
            },
            {
              "question": "What is the result of `range(3)`?",
              "options": [
                "A list of [0, 1, 2, 3]",
                "A tuple of (0, 1, 2)",
                "An iterable object representing the sequence 0, 1, 2",
                "The number 3"
              ],
              "type": "mcq",
              "answer": "An iterable object representing the sequence 0, 1, 2"
            },
            {
              "question": "Which statement is used to exit a loop entirely?",
              "type": "one-word",
              "answer": "break"
            },
            {
              "question": "What is the key characteristic of a tuple?",
              "type": "one-word",
              "answer": "Immutability"
            },
            {
              "question": "Which data structure uses key-value pairs?",
              "options": [
                "List",
                "Tuple",
                "Dictionary",
                "Set"
              ],
              "type": "mcq",
              "answer": "Dictionary"
            },
            {
              "question": "What does a `while` loop continue to do as long as its condition is?",
              "type": "one-word",
              "answer": "True"
            },
            {
              "question": "What is the primary feature of a set?",
              "type": "one-word",
              "answer": "Uniqueness"
            }
          ]
        },
        {
          "chapterNumber": 3,
          "chapterTitle": "Functions and Modularity",
          "subtopics": [
            {
              "subtopicTitle": "Defining and Calling Functions",
              "explanation": "A **function** in Python is a reusable block of code that performs a specific task. Functions help organize code, making it more modular, readable, and easier to maintain. They are a core concept in all programming languages. To define a function in Python, you use the `def` keyword, followed by the function name, parentheses `()`, and a colon `:`. The code block for the function must be indented. Functions can optionally accept input values, known as **arguments** or **parameters**, which are specified within the parentheses. They can also return a value using the `return` statement. The basic syntax is: `def function_name(parameters): \n    \"\"\"Docstring explaining the function\"\"\" \n    # Function code block \n    return result`. The docstring is a string literal that describes the function's purpose and is a best practice for code documentation. To execute the code inside a function, you must **call** it by its name followed by parentheses. If the function expects arguments, you must provide them when calling it. For example, if you define `def greet(name): print(f'Hello, {name}')`, you would call it with `greet('Alice')`. Functions can also return a value, which can then be stored in a variable or used in an expression. For instance, `def add(a, b): return a + b`. You would call this as `result = add(5, 3)`, and `result` would be `8`. Functions are essential for breaking down complex problems into smaller, manageable pieces, and they promote the concept of **Don't Repeat Yourself (DRY)** by allowing you to reuse the same code block multiple times.",
              "examples": [
                "A function that greets a person: `def greet(name): \n    print(f'Hello, {name}!') \n\ngreet('Bob')`",
                "A function that returns a calculation: `def square(x): \n    return x * x \n\narea = square(4)`"
              ]
            },
            {
              "subtopicTitle": "Arguments and Parameters",
              "explanation": "Understanding how to pass data to and from functions is crucial. The terms **parameter** and **argument** are often used interchangeably, but they have a subtle distinction. A **parameter** is the variable listed inside the parentheses in the function definition, e.g., `name` in `def greet(name):`. An **argument** is the actual value passed to the function when it is called, e.g., `'Alice'` in `greet('Alice')`. Python supports several ways of passing arguments. **Positional arguments** are the most common; they are passed in the same order as their corresponding parameters. For example, `def power(base, exponent): ...` would require you to call it as `power(2, 3)`. **Keyword arguments** are passed by explicitly naming the parameter. This allows you to pass arguments in any order and makes the function call more readable. `power(exponent=3, base=2)` is a valid keyword argument call. You can also define **default arguments**, which are parameters that have a default value if no argument is provided. For example, `def greet(name, message='Hello'): ...`. If you call `greet('Bob')`, the `message` will be 'Hello'. **Arbitrary arguments** (`*args` for non-keyword arguments and `**kwargs` for keyword arguments) allow a function to accept a variable number of arguments. This is useful when you don't know in advance how many arguments will be passed to your function. Mastering these different ways of handling arguments gives you a lot of flexibility and control over how your functions are used. It allows you to create versatile functions that can be adapted to a variety of situations without needing to write a separate function for each case.",
              "examples": [
                "Function with positional arguments: `def divide(a, b): return a / b; divide(10, 2)`",
                "Function with a default argument: `def say_hello(name, lang='en'): ...; say_hello('Alex', 'es')`"
              ]
            },
            {
              "subtopicTitle": "Modules and Packages",
              "explanation": "As programs grow in size, it becomes impractical to keep all the code in a single file. This is where **modularity** comes in, and in Python, it's implemented using **modules** and **packages**. A **module** is simply a Python file (`.py` file) that contains Python code, such as functions, classes, and variables. To use the code from a module, you need to import it using the `import` keyword. For example, if you have a file named `calculator.py` with an `add` function, you can use it in another file by writing `import calculator` and then calling the function as `calculator.add(5, 3)`. You can also import specific functions or variables from a module using `from module_name import function_name`. This allows you to use the function directly without the module prefix, like `from calculator import add; add(5, 3)`. A **package** is a way of organizing related modules into a directory hierarchy. A package directory must contain a special file named `__init__.py` (which can be empty) to be recognized as a package. Packages allow for better organization of larger projects and prevent name conflicts. For example, if you have a `geometry` package with `shapes.py` and `colors.py` modules inside it, you can import them as `from geometry import shapes`. Python's standard library is a collection of built-in modules and packages that come with the language installation, providing tools for everything from mathematical operations to file handling. The ability to import and reuse code from modules and packages is a cornerstone of modern software development, enabling collaboration and the creation of large, maintainable applications.",
              "examples": [
                "Importing the `math` module: `import math; print(math.sqrt(16))`",
                "Importing a specific function: `from random import randint; print(randint(1, 10))`"
              ]
            }
          ],
          "chapterSummary": "Chapter 3 focused on the crucial concepts of functions and modularity. We began by learning how to define and call functions using the `def` keyword, understanding how they help organize and reuse code. We then explored the different ways to pass data to functions through arguments, including positional, keyword, and default arguments. Finally, we learned about modules and packages, which allow us to organize our code into separate files and directories, promoting better code structure and reusability through the `import` statement.",
          "quiz": [
            {
              "question": "Which keyword is used to define a function in Python?",
              "type": "one-word",
              "answer": "def"
            },
            {
              "question": "What is a reusable block of code that performs a specific task called?",
              "type": "one-word",
              "answer": "Function"
            },
            {
              "question": "What is the name for the values a function expects as input in its definition?",
              "type": "one-word",
              "answer": "Parameters"
            },
            {
              "question": "What is the purpose of the `return` statement in a function?",
              "options": [
                "To print a value to the console",
                "To terminate the function without a value",
                "To send a value back to the caller",
                "To define a new variable"
              ],
              "type": "mcq",
              "answer": "To send a value back to the caller"
            },
            {
              "question": "Which of the following is a Python file that contains code and can be imported?",
              "options": [
                "A package",
                "A module",
                "A library",
                "A class"
              ],
              "type": "mcq",
              "answer": "A module"
            },
            {
              "question": "Which keyword is used to bring a module into your current file?",
              "type": "one-word",
              "answer": "import"
            },
            {
              "question": "What is the term for an actual value passed to a function when it is called?",
              "type": "one-word",
              "answer": "Argument"
            },
            {
              "question": "What does a package directory contain to be recognized as a package?",
              "type": "one-word",
              "answer": "__init__.py"
            },
            {
              "question": "Which type of argument allows you to pass a variable number of non-keyword arguments?",
              "options": [
                "Keyword arguments",
                "Default arguments",
                "Arbitrary arguments",
                "Positional arguments"
              ],
              "type": "mcq",
              "answer": "Arbitrary arguments"
            },
            {
              "question": "The string literal used to describe a function's purpose is called a _______________.",
              "type": "one-word",
              "answer": "Docstring"
            }
          ]
        },
        {
          "chapterNumber": 4,
          "chapterTitle": "Object-Oriented Programming (OOP) in Python",
          "subtopics": [
            {
              "subtopicTitle": "Introduction to OOP: Classes and Objects",
              "explanation": "**Object-Oriented Programming (OOP)** is a programming paradigm that uses 'objects' to design applications and computer programs. These objects are instances of **classes**, which act as blueprints. OOP focuses on bundling data and the functions that operate on that data into a single unit, which is the object. This approach helps in managing complex software by modeling real-world entities. A **class** is a blueprint or a template for creating objects. It defines the properties (attributes) and behaviors (methods) that an object of that class will have. For example, a `Car` class might have attributes like `color` and `make`, and methods like `start_engine()` and `drive()`. To define a class in Python, you use the `class` keyword. The basic syntax is `class ClassName: \n    # class body`. An **object** is a specific instance of a class. When you create an object, you are instantiating the class. For example, `my_car = Car('blue', 'Toyota')` would create a new `Car` object named `my_car` with the color 'blue' and make 'Toyota'. The object `my_car` would then have access to the `start_engine()` and `drive()` methods defined in the `Car` class. A key concept in OOP is the special `__init__` method, which is a constructor. It is automatically called when a new object is created and is used to initialize the object's attributes. The `self` parameter in a method refers to the instance of the object itself. OOP promotes code reusability, organization, and a more intuitive way of thinking about program design, which is why it is so widely used in modern software development. ",
              "examples": [
                "Defining a simple class: `class Dog: \n    def bark(self): \n        print('Woof!') \n\nmy_dog = Dog() \nmy_dog.bark()`"
              ]
            },
            {
              "subtopicTitle": "Attributes and Methods",
              "explanation": "In the context of OOP, **attributes** and **methods** are the core components of a class. **Attributes** are variables that belong to an object. They represent the state or properties of the object. For example, in a `Student` class, attributes could be `name`, `student_id`, and `major`. Attributes are defined within the class and are typically initialized in the `__init__` constructor method. You access an object's attributes using the dot notation, like `student1.name`. Attributes can be either **instance attributes** (specific to a particular object, like `student1.name`) or **class attributes** (shared by all objects of the class, like a `MINIMUM_GPA` constant). **Methods** are functions that belong to a class and define the behaviors of an object. They are defined just like regular functions but are placed inside the class definition and have `self` as their first parameter, which is a reference to the instance itself. For example, a `Student` class might have a method `get_gpa()` that returns the student's GPA or a `register_for_course()` method that modifies the student's enrolled courses. Methods are also called using dot notation, like `student1.get_gpa()`. The `self` parameter is automatically passed by Python when you call a method on an object. Understanding the distinction between attributes (the data) and methods (the behavior) is central to building effective object-oriented programs. This separation of concerns allows for the creation of well-structured and maintainable code, where the state and actions of an object are clearly defined.",
              "examples": [
                "A class with attributes and a method: `class Circle: \n    def __init__(self, radius): \n        self.radius = radius \n    def area(self): \n        return 3.14 * self.radius * self.radius \n\ncircle1 = Circle(5) \nprint(circle1.radius) \nprint(circle1.area())`"
              ]
            },
            {
              "subtopicTitle": "Inheritance and Polymorphism",
              "explanation": "Two of the most powerful concepts in OOP are **inheritance** and **polymorphism**. **Inheritance** is a mechanism that allows a new class (**child class** or **subclass**) to inherit attributes and methods from an existing class (**parent class** or **superclass**). This promotes code reuse and creates a hierarchical relationship between classes. The child class can extend or modify the behavior of the parent class. For example, you could have a `Vehicle` parent class with a `drive()` method, and then a `Car` and `Motorcycle` child classes that inherit from `Vehicle`. The child classes can then have their own specific attributes and methods, like a `Car` having `num_doors`. To create a child class, you specify the parent class in parentheses in the class definition: `class ChildClass(ParentClass): ...`. The `super()` function is often used in the child class's `__init__` method to call the parent's constructor. **Polymorphism** (meaning 'many forms') is the ability of an object to take on many forms. In the context of inheritance, it means that a child class can override a method from its parent class to provide its own implementation. For example, both `Car` and `Motorcycle` might have a `drive()` method, but their implementations could be different. Polymorphism also allows a single function to operate on objects of different classes that are related by inheritance. For instance, a function that takes a `Vehicle` object as an argument can accept a `Car` object or a `Motorcycle` object, and the appropriate `drive()` method for that specific object will be called. Inheritance and polymorphism are key to building flexible and extensible programs, as they allow for the creation of a clean, logical structure for your code.",
              "examples": [
                "Inheritance: `class Animal: \n    def speak(self): print('Animal sound') \nclass Dog(Animal): \n    def speak(self): print('Woof') \n\nmy_dog = Dog() \nmy_dog.speak()`"
              ]
            }
          ],
          "chapterSummary": "Chapter 4 provided an introduction to Object-Oriented Programming (OOP) in Python. We started by defining classes as blueprints and objects as instances of those classes, which bundle data and behavior. We then distinguished between attributes (data) and methods (functions) that belong to a class. Finally, we explored the core principles of inheritance, which allows classes to inherit from other classes, and polymorphism, which enables objects to take on different forms and allows for method overriding. These concepts are fundamental to building structured, reusable, and scalable applications.",
          "quiz": [
            {
              "question": "What is a class in Object-Oriented Programming?",
              "type": "one-word",
              "answer": "Blueprint"
            },
            {
              "question": "What is a specific instance of a class called?",
              "type": "one-word",
              "answer": "Object"
            },
            {
              "question": "What is the name for the functions that belong to a class?",
              "type": "one-word",
              "answer": "Methods"
            },
            {
              "question": "Which special method is automatically called when a new object is created?",
              "options": [
                "__init__",
                "__main__",
                "__new__",
                "__call__"
              ],
              "type": "mcq",
              "answer": "__init__"
            },
            {
              "question": "What is the term for the process where a child class inherits from a parent class?",
              "options": [
                "Polymorphism",
                "Encapsulation",
                "Inheritance",
                "Abstraction"
              ],
              "type": "mcq",
              "answer": "Inheritance"
            },
            {
              "question": "What is the name for the variables that belong to an object?",
              "type": "one-word",
              "answer": "Attributes"
            },
            {
              "question": "What is the first parameter of a method that refers to the instance itself?",
              "type": "one-word",
              "answer": "self"
            },
            {
              "question": "The ability of an object to take on many forms is called _______________.",
              "type": "one-word",
              "answer": "Polymorphism"
            },
            {
              "question": "How is a child class created in Python?",
              "options": [
                "By using the 'new' keyword",
                "By listing the parent class in parentheses",
                "By using the 'inherit' keyword",
                "By using the `super()` function"
              ],
              "type": "mcq",
              "answer": "By listing the parent class in parentheses"
            },
            {
              "question": "What is the key benefit of inheritance in OOP?",
              "type": "one-word",
              "answer": "Code reuse"
            }
          ]
        },
        {
          "chapterNumber": 5,
          "chapterTitle": "File Handling and Error Handling",
          "subtopics": [
            {
              "subtopicTitle": "Reading and Writing to Files",
              "explanation": "Interacting with files is a fundamental task in many applications. Python provides built-in functions for **file handling**, allowing you to read data from a file or write data to a file. The primary function for this is `open()`, which takes the filename and a mode as arguments. The mode specifies how the file will be used: `'r'` for reading (the default), `'w'` for writing (overwriting the file), `'a'` for appending (adding to the end of the file), and `'x'` for exclusive creation (failing if the file already exists). The best practice for handling files is to use the `with` statement, which ensures that the file is automatically closed, even if errors occur. The syntax is `with open('filename.txt', 'mode') as f: # code to read/write`. To **read from a file**, you can use methods like `f.read()` to read the entire content, `f.readline()` to read a single line, or `f.readlines()` to read all lines into a list. For example, `with open('data.txt', 'r') as f: content = f.read()`. To **write to a file**, you use methods like `f.write(string)` or `f.writelines(list_of_strings)`. For example, `with open('output.txt', 'w') as f: f.write('Hello, world!')`. When writing, the `'w'` mode will create the file if it doesn't exist or overwrite it if it does. If you want to add content without deleting the existing content, you would use the `'a'` (append) mode. Python's file handling capabilities are crucial for tasks like processing log files, storing application data, or generating reports. ",
              "examples": [
                "Writing to a file: `with open('my_file.txt', 'w') as file: \n    file.write('This is a new line.')`",
                "Reading from a file: `with open('my_file.txt', 'r') as file: \n    content = file.read() \n    print(content)`"
              ]
            },
            {
              "subtopicTitle": "Understanding and Handling Errors: `try` and `except`",
              "explanation": "When a program encounters an error that prevents it from running, it raises an **exception**. Examples of exceptions include a `NameError` if a variable is not defined, a `TypeError` if an operation is performed on an incompatible data type, or a `FileNotFoundError` if you try to open a file that doesn't exist. Instead of letting the program crash, you can use **error handling** to gracefully handle these exceptions. The primary tool for this in Python is the `try...except` block. The `try` block contains the code that might raise an exception. If an exception occurs within the `try` block, the program's execution jumps to the `except` block. The `except` block contains the code that will be executed to handle the error. The basic syntax is `try: \n    # Code that might raise an error \nexcept ExceptionType: \n    # Code to handle the error`. You can specify a particular `ExceptionType` to catch specific errors. For example, `except FileNotFoundError:`. If you don't specify an exception type, it will catch any error. It's also possible to have multiple `except` blocks to handle different types of exceptions. The `else` block can be included after all `except` blocks and will execute only if the code in the `try` block runs without any errors. The `finally` block is optional and is always executed, whether an exception occurred or not. It is often used for cleanup actions, such as closing a file. Proper error handling is essential for building robust and reliable applications that can handle unexpected situations without crashing. It allows your program to fail gracefully and continue running.",
              "examples": [
                "Handling a `ZeroDivisionError`: `try: \n    result = 10 / 0 \nexcept ZeroDivisionError: \n    print('Cannot divide by zero!')`",
                "Handling file-not-found errors: `try: \n    with open('non_existent.txt', 'r') as file: \n        content = file.read() \nexcept FileNotFoundError: \n    print('The file was not found.')`"
              ]
            },
            {
              "subtopicTitle": "The `with` Statement for Context Management",
              "explanation": "The **`with` statement** is a powerful and elegant feature in Python that simplifies the management of resources, such as files, database connections, and network sockets. It is part of Python's **context management protocol**. The primary benefit of using `with` is that it guarantees a resource is properly cleaned up, even if an exception occurs. When you use the `with` statement, a **context manager** is used to handle the setup and teardown of a resource. For example, when you open a file with `with open('file.txt', 'r') as f:`, the `open()` function is the context manager. When the `with` block is entered, the file is opened. When the block is exited, whether it's through normal execution or because of an error, the context manager's `__exit__` method is automatically called, which ensures the file is closed. This prevents common programming errors like leaving files open, which can lead to resource leaks and other issues. Prior to the `with` statement, you would have to use a `try...finally` block to ensure a file was closed, which is more verbose and less readable. The `with` statement is not limited to file handling; it can be used with any object that supports the context manager protocol, which includes many objects in the standard library and third-party libraries. This makes `with` a versatile tool for writing clean, safe, and efficient code. By automatically managing resources, it reduces the risk of errors and makes your code more reliable.",
              "examples": [
                "Using `with` to ensure a file is closed: `with open('my_data.txt', 'w') as f: \n    f.write('Some data') \n# The file is now guaranteed to be closed.`"
              ]
            }
          ],
          "chapterSummary": "Chapter 5 focused on essential practices for building robust and reliable Python applications. We first covered file handling, learning how to read from and write to files using the `open()` function and the recommended `with` statement. We then delved into error handling, using `try`, `except`, and `finally` blocks to gracefully manage exceptions and prevent program crashes. Finally, we explored the `with` statement in more detail, understanding its role as a context manager to ensure resources are properly cleaned up, which is a best practice for writing safe and efficient code.",
          "quiz": [
            {
              "question": "What is the default mode for the `open()` function?",
              "type": "one-word",
              "answer": "'r'"
            },
            {
              "question": "Which block is used to handle code that might raise an exception?",
              "type": "one-word",
              "answer": "try"
            },
            {
              "question": "Which of the following is an advantage of using the `with` statement for file handling?",
              "options": [
                "It makes the file read-only",
                "It automatically closes the file",
                "It speeds up file operations",
                "It prevents all errors"
              ],
              "type": "mcq",
              "answer": "It automatically closes the file"
            },
            {
              "question": "Which mode is used to write to a file, overwriting its contents if it exists?",
              "type": "one-word",
              "answer": "'w'"
            },
            {
              "question": "The `except` block is executed only if an exception is raised in the `try` block. True or False?",
              "options": [
                "True",
                "False"
              ],
              "type": "mcq",
              "answer": "True"
            },
            {
              "question": "The `finally` block is always executed, whether an exception occurred or not. True or False?",
              "type": "one-word",
              "answer": "True"
            },
            {
              "question": "What is a `FileNotFoundError` an example of?",
              "type": "one-word",
              "answer": "Exception"
            },
            {
              "question": "Which method reads all lines from a file into a list?",
              "options": [
                "read()",
                "readline()",
                "readlines()",
                "getlines()"
              ],
              "type": "mcq",
              "answer": "readlines()"
            },
            {
              "question": "Which keyword is used to append to a file?",
              "type": "one-word",
              "answer": "'a'"
            },
            {
              "question": "What does a `try...except` block do?",
              "type": "one-word",
              "answer": "Handles errors"
            }
          ]
        }
      ]
    },
    {
      "courseTitle": "Introduction to SQL",
      "difficulty": "Intermediate",
      "description": "This course provides a comprehensive introduction to Structured Query Language (SQL), the standard language for managing relational databases. Learners will gain a solid foundation in SQL, starting with basic syntax and data retrieval, and progressing to more complex operations like data manipulation, joins, and database design. The course is suitable for beginners with no prior database experience.",
      "chapters": [
        {
          "chapterNumber": 1,
          "chapterTitle": "Introduction to Databases and SQL",
          "subtopics": [
            {
              "subtopicTitle": "What is SQL? An Overview",
              "explanation": "SQL, which stands for **Structured Query Language**, is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS). It's the standard language for relational database management systems. SQL statements are used to retrieve and update data in a database. SQL is a declarative language, meaning you tell the database what you want to achieve, rather than how to achieve it. This makes it powerful and relatively easy to learn, as the database engine handles the complex task of finding the most efficient way to execute your command. The language is built around a set of keywords like `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `CREATE`, and `ALTER`. These keywords form the basis of all SQL commands. SQL is not a programming language in the traditional sense like Python or Java; it's a language specifically for interacting with databases. It allows you to perform four main categories of tasks: **Data Query Language (DQL)** for retrieving data (`SELECT`), **Data Manipulation Language (DML)** for modifying data (`INSERT`, `UPDATE`, `DELETE`), **Data Definition Language (DDL)** for defining database schema (`CREATE`, `ALTER`, `DROP`), and **Data Control Language (DCL)** for managing user permissions (`GRANT`, `REVOKE`). Almost all modern relational database systems, including MySQL, PostgreSQL, Oracle, and Microsoft SQL Server, use SQL as their primary language, although each may have its own proprietary extensions. Understanding SQL is a fundamental skill for anyone working with data, from developers to data analysts and business intelligence professionals.",
              "examples": [
                "A simple query to select all data from a table named `customers`: `SELECT * FROM customers;`"
              ]
            },
            {
              "subtopicTitle": "Relational Databases: Tables, Rows, and Columns",
              "explanation": "A **relational database** is a type of database that organizes data into one or more tables (or 'relations') of columns and rows. It's the most common type of database in use today. The fundamental concept of a relational database is that data is stored in a structured format, where each table represents a specific entity, like `employees` or `products`. Each table consists of **rows** and **columns**. A **column** (also known as a field or attribute) defines a specific piece of information for each entry. For example, in an `employees` table, columns might be `employee_id`, `first_name`, `last_name`, and `hire_date`. Each column has a data type, such as `INTEGER` for `employee_id` or `VARCHAR` for `first_name`, which ensures data integrity. A **row** (also known as a record or tuple) represents a single, complete entry within the table. In our `employees` table, a row would contain all the information for a single employee. The power of a relational database lies in the ability to establish relationships between tables. This is done through the use of **primary keys** and **foreign keys**. A **primary key** is a unique identifier for each row in a table. It cannot be null and must be unique. A **foreign key** is a column or a set of columns in one table that refers to the primary key in another table. This creates a link between the two tables, allowing us to combine data from multiple sources. For instance, an `orders` table might have a `customer_id` column that is a foreign key referencing the `customer_id` primary key in a `customers` table. This structure helps avoid data redundancy and ensures data consistency.",
              "examples": [
                "A table named `students` with columns `student_id`, `name`, `major`, and `gpa`. Each row in this table would represent a single student with their unique ID, name, major, and GPA."
              ]
            },
            {
              "subtopicTitle": "Setting up a Database and Using a Client",
              "explanation": "Before you can start writing SQL queries, you need a database to work with and a client to connect to it. A **database management system (DBMS)** is the software that manages the database itself. Common examples of RDBMSs include **MySQL**, **PostgreSQL**, **SQLite**, and **Microsoft SQL Server**. For this course, we'll focus on the general concepts that apply to most of them. The first step is to install a DBMS on your computer. Many of these are open-source and free to use, such as MySQL and PostgreSQL. Installation typically involves downloading the software and following the setup instructions. Once the DBMS is installed, you'll need to create a database instance, which is a container for your tables and data. The next step is to connect to this database using a **database client**. A database client is a tool that allows you to send SQL commands to the database and view the results. These clients can be command-line interfaces (CLIs) or graphical user interfaces (GUIs). **Command-line clients** are often included with the DBMS installation, like `mysql` or `psql`, and are great for quick tasks and scripting. **Graphical clients** provide a visual interface for managing your database. Popular examples include **DBeaver**, **TablePlus**, and **SQL Developer**. These tools offer features like schema Browse, query editors with syntax highlighting, and data visualization. Using a GUI client is often recommended for beginners as it provides a more intuitive way to interact with the database. The client establishes a connection to the DBMS, typically requiring a hostname (like `localhost`), a port number, a username, and a password. Once connected, you can create tables and start running your SQL queries.",
              "examples": [
                "Installing MySQL on your local machine and then using a GUI client like DBeaver to connect to it. You would provide the hostname `localhost`, the default port `3306`, and your user credentials to establish the connection."
              ]
            }
          ],
          "chapterSummary": "Chapter 1 provides a foundational understanding of SQL and relational databases. We learned that SQL is the standard language for managing data in relational databases, which organize data into tables with rows and columns. We also covered the key concepts of primary and foreign keys for establishing relationships between tables. Finally, we discussed the practical steps of setting up a database management system (like MySQL) and using a client to interact with it, preparing us for writing our first SQL queries.",
          "quiz": [
            {
              "question": "What does SQL stand for?",
              "type": "one-word",
              "answer": "Structured Query Language"
            },
            {
              "question": "What is the primary function of a 'row' in a database table?",
              "type": "one-word",
              "answer": "Record"
            },
            {
              "question": "What type of key uniquely identifies each row in a table?",
              "type": "one-word",
              "answer": "Primary"
            },
            {
              "question": "Which of the following is not a category of SQL statements?",
              "options": [
                "Data Query Language (DQL)",
                "Data Manipulation Language (DML)",
                "Data Presentation Language (DPL)",
                "Data Definition Language (DDL)"
              ],
              "type": "mcq",
              "answer": "Data Presentation Language (DPL)"
            },
            {
              "question": "What is a column in a database table also known as?",
              "options": [
                "A record",
                "An attribute",
                "A tuple",
                "A key"
              ],
              "type": "mcq",
              "answer": "An attribute"
            },
            {
              "question": "A key that links a row in one table to a row in another table is called a _______________ key.",
              "type": "one-word",
              "answer": "Foreign"
            },
            {
              "question": "Which of the following is a common open-source database management system?",
              "options": [
                "Adobe Photoshop",
                "Microsoft Word",
                "MySQL",
                "Google Chrome"
              ],
              "type": "mcq",
              "answer": "MySQL"
            },
            {
              "question": "Which SQL command is used for retrieving data from a database?",
              "type": "one-word",
              "answer": "SELECT"
            },
            {
              "question": "A graphical tool used to connect to a database and run queries is called a database _______________.",
              "type": "one-word",
              "answer": "Client"
            },
            {
              "question": "In a relational database, data is organized into what?",
              "options": [
                "Files and folders",
                "Tables, rows, and columns",
                "Web pages",
                "Spreadsheets"
              ],
              "type": "mcq",
              "answer": "Tables, rows, and columns"
            }
          ]
        },
        {
          "chapterNumber": 2,
          "chapterTitle": "Retrieving Data with SELECT",
          "subtopics": [
            {
              "subtopicTitle": "The `SELECT` Statement and `FROM` Clause",
              "explanation": "The **`SELECT` statement** is the most fundamental and widely used command in SQL. It is used to retrieve data from one or more tables in a database. The basic structure of a `SELECT` query consists of two essential clauses: `SELECT` and `FROM`. The `SELECT` clause specifies which columns you want to retrieve from the table. You can list the specific column names, separated by commas, or you can use an asterisk (`*`) as a wildcard to select all columns. The `FROM` clause specifies the table from which you want to retrieve the data. This is where you name the table you're querying. The basic syntax is `SELECT column1, column2, ... FROM table_name;`. For example, `SELECT first_name, last_name FROM employees;` would retrieve only the first and last names of all employees. Using `SELECT * FROM employees;` would return every column for every employee. It's important to be specific and only select the columns you need, especially when working with large tables, as this can improve query performance. The `SELECT` statement is the core of **Data Query Language (DQL)**. It's a powerful tool that allows you to pull specific pieces of information from a database, which is the foundation of data analysis and reporting. The `FROM` clause is crucial because it tells the database where to look for the data you're requesting. Without a `FROM` clause, the database wouldn't know which table to query, and the statement would fail. The combination of `SELECT` and `FROM` is the simplest form of a SQL query, but it forms the building blocks for much more complex and powerful queries that we'll explore later in the course.",
              "examples": [
                "To get all columns from a table named `products`: `SELECT * FROM products;`",
                "To get only the `product_name` and `price` from the `products` table: `SELECT product_name, price FROM products;`"
              ]
            },
            {
              "subtopicTitle": "Filtering Data with the `WHERE` Clause",
              "explanation": "While `SELECT` and `FROM` allow you to retrieve data from a table, the **`WHERE` clause** is what allows you to filter that data. The `WHERE` clause is used to specify a condition that must be met for a row to be included in the result set. It comes after the `FROM` clause in a `SELECT` statement. The basic syntax is `SELECT column1, column2, ... FROM table_name WHERE condition;`. The `condition` is an expression that evaluates to true, false, or unknown. SQL provides a wide range of operators for building these conditions, including comparison operators (`=`, `!=`, `<`, `>`, `<=`, `>=`), logical operators (`AND`, `OR`, `NOT`), and special operators (`IN`, `BETWEEN`, `LIKE`, `IS NULL`). For instance, `SELECT * FROM employees WHERE city = 'New York';` will only return employees who live in 'New York'. You can combine conditions using `AND` and `OR` to create more specific filters. For example, `SELECT * FROM products WHERE price > 50 AND stock_quantity > 10;` will return products that cost more than $50 and have more than 10 units in stock. The `WHERE` clause is essential for retrieving a specific subset of data that is relevant to your needs. It is the key to creating targeted and meaningful queries, allowing you to narrow down your results from millions of records to just a handful. ",
              "examples": [
                "To find all customers from 'California': `SELECT * FROM customers WHERE state = 'California';`",
                "To find products with a price between 10 and 20: `SELECT * FROM products WHERE price BETWEEN 10 AND 20;`"
              ]
            },
            {
              "subtopicTitle": "Sorting and Limiting Results with `ORDER BY` and `LIMIT`",
              "explanation": "After you've selected and filtered your data, you often need to organize it in a specific way. The **`ORDER BY` clause** is used to sort the result set in ascending or descending order. By default, `ORDER BY` sorts in **ascending (ASC)** order. To sort in descending order, you must explicitly specify the **`DESC`** keyword. You can sort by one or more columns. For example, `SELECT * FROM employees ORDER BY last_name ASC;` will sort all employees alphabetically by their last name. To sort by multiple columns, you list them in the order of precedence. `SELECT * FROM employees ORDER BY department_id ASC, last_name ASC;` would first sort by department, and then within each department, it would sort by last name. The `ORDER BY` clause is typically the last clause in a `SELECT` statement. The **`LIMIT` clause** (or `TOP` in some SQL dialects like Microsoft SQL Server) is used to restrict the number of rows returned by the query. This is particularly useful when you're working with very large tables and only need to see the first few results, or when you're implementing pagination for an application. For example, `SELECT * FROM products ORDER BY price DESC LIMIT 10;` will return the 10 most expensive products. The `LIMIT` clause is often used in combination with `ORDER BY` to get the 'top' or 'bottom' N records based on a certain criterion. It's a crucial tool for performance optimization and for getting a quick overview of your data without having to fetch the entire result set. The combination of `SELECT`, `FROM`, `WHERE`, `ORDER BY`, and `LIMIT` allows for precise and efficient data retrieval.",
              "examples": [
                "To get the 5 newest employees based on their hire date: `SELECT * FROM employees ORDER BY hire_date DESC LIMIT 5;`",
                "To sort a list of products by category and then by price: `SELECT * FROM products ORDER BY category ASC, price DESC;`"
              ]
            }
          ],
          "chapterSummary": "Chapter 2 focused on the core of data retrieval using the `SELECT` statement. We learned that the `SELECT` clause specifies the columns to be retrieved, and the `FROM` clause specifies the source table. The `WHERE` clause is used to filter data based on specific conditions, allowing us to retrieve only relevant records. Finally, we explored how to sort our results using `ORDER BY` and how to limit the number of rows returned with the `LIMIT` clause, which is essential for managing and presenting data effectively.",
          "quiz": [
            {
              "question": "What is the primary function of the `SELECT` statement?",
              "type": "one-word",
              "answer": "Retrieve"
            },
            {
              "question": "Which clause is used to specify the table from which to retrieve data?",
              "type": "one-word",
              "answer": "FROM"
            },
            {
              "question": "To select all columns from a table, what symbol should you use?",
              "type": "one-word",
              "answer": "*"
            },
            {
              "question": "Which of the following clauses is used to filter data based on a condition?",
              "options": [
                "SELECT",
                "FROM",
                "WHERE",
                "ORDER BY"
              ],
              "type": "mcq",
              "answer": "WHERE"
            },
            {
              "question": "What keyword is used to sort results in descending order?",
              "options": [
                "ASC",
                "DESC",
                "SORT",
                "ORDER"
              ],
              "type": "mcq",
              "answer": "DESC"
            },
            {
              "question": "Which clause is used to limit the number of rows returned by a query?",
              "type": "one-word",
              "answer": "LIMIT"
            },
            {
              "question": "The `AND` and `OR` operators are used in which clause?",
              "type": "one-word",
              "answer": "WHERE"
            },
            {
              "question": "What is the default sorting order when using `ORDER BY` without specifying `ASC` or `DESC`?",
              "type": "one-word",
              "answer": "Ascending"
            },
            {
              "question": "Which clause typically comes before `ORDER BY` in a `SELECT` statement?",
              "options": [
                "FROM",
                "SELECT",
                "WHERE",
                "All of the above"
              ],
              "type": "mcq",
              "answer": "WHERE"
            },
            {
              "question": "A query that returns the top 5 most recent sales would use which two clauses in combination?",
              "type": "one-word",
              "answer": "ORDER BY and LIMIT"
            }
          ]
        },
        {
          "chapterNumber": 3,
          "chapterTitle": "Manipulating Data with DML",
          "subtopics": [
            {
              "subtopicTitle": "Inserting New Data with `INSERT`",
              "explanation": "The `INSERT` statement is a key component of **Data Manipulation Language (DML)** and is used to add new rows of data into a table. There are two primary syntaxes for the `INSERT` statement. The first and most common method is to specify the columns you are inserting data into and then provide the values. The syntax is `INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...);`. The column names and the values must be in the same order and have compatible data types. For instance, if `column1` is an integer, `value1` must be an integer. It is considered a best practice to always specify the column names, even if you are inserting values for every column, as this makes your code more readable and less prone to errors if the table schema changes. A second, less-preferred method is to insert values for every column without explicitly naming them. This works as long as the number of values and their order match the table's column order precisely. The syntax is `INSERT INTO table_name VALUES (value1, value2, value3, ...);`. You can also insert multiple rows at once by separating the value sets with commas, like `INSERT INTO table_name (column1) VALUES (valueA), (valueB), (valueC);`. The `INSERT` statement is a foundational command for populating a database with data, whether it's from a user form, an application, or a data migration script. Proper use of `INSERT` is crucial for maintaining the integrity and completeness of your database, as it is the gateway for all new information. When a new record is successfully added, most database systems will return a message indicating the number of rows affected. ",
              "examples": [
                "To add a new employee to an `employees` table: `INSERT INTO employees (first_name, last_name, email) VALUES ('John', 'Doe', 'john.doe@example.com');`",
                "To insert a new product with all columns: `INSERT INTO products VALUES (101, 'Laptop', 'Electronics', 1200.00, 50);`"
              ]
            },
            {
              "subtopicTitle": "Modifying Existing Data with `UPDATE`",
              "explanation": "The **`UPDATE` statement** is used to modify existing records in a table. It is another critical DML command. The basic syntax is `UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;`. The `SET` clause specifies the column(s) you want to change and the new value(s). The `WHERE` clause is absolutely essential because it determines which rows will be affected by the update. **If you omit the `WHERE` clause, the `UPDATE` statement will modify every single row in the table**, which is a very common and potentially disastrous mistake. For example, `UPDATE products SET price = 100;` would change the price of every product in the `products` table to 100. This is why it's a best practice to always test your `WHERE` clause with a `SELECT` statement first to ensure it targets the correct rows. You can update a single column or multiple columns at once. For example, `UPDATE employees SET salary = salary * 1.05 WHERE department_id = 3;` would give a 5% raise to all employees in department 3. The `UPDATE` statement is vital for keeping your data current and accurate. It's used to correct errors, apply promotions, or change statuses. Just like with `INSERT`, the database will usually return a message indicating how many rows were updated, which is a good way to verify that your query did what you intended it to do.",
              "examples": [
                "To update the email address for an employee with `employee_id` 123: `UPDATE employees SET email = 'jane.doe@newcompany.com' WHERE employee_id = 123;`",
                "To mark a product as out of stock: `UPDATE products SET stock_quantity = 0, status = 'Out of Stock' WHERE product_id = 456;`"
              ]
            },
            {
              "subtopicTitle": "Deleting Data with `DELETE`",
              "explanation": "The **`DELETE` statement** is the third major DML command, and it is used to remove one or more rows from a table. The basic syntax is `DELETE FROM table_name WHERE condition;`. Similar to the `UPDATE` statement, the `WHERE` clause is a critical component. **If you omit the `WHERE` clause, the `DELETE` statement will remove all rows from the table**, essentially emptying it completely. This is another very dangerous operation that requires careful attention. For this reason, it's a good practice to use a `SELECT` statement with the same `WHERE` clause before running a `DELETE` to ensure you're targeting the correct rows. For example, `DELETE FROM employees WHERE department_id = 5;` would remove all employees who work in department 5. If you wanted to remove a single record, you would use a primary key in the `WHERE` clause, like `DELETE FROM products WHERE product_id = 999;`. The `DELETE` statement is used when records are no longer needed, such as when an employee leaves the company or a product is discontinued. While it's a powerful tool, it's also a permanent one, and deleted data is not easily recovered. Some database systems allow for transaction control, which can be used to roll back a `DELETE` operation if it was performed in error, but this is a more advanced topic. The `DELETE` statement only removes the data (rows) from the table; it does not remove the table itself or its structure. To remove an entire table, you would use the DDL command `DROP TABLE`.",
              "examples": [
                "To delete all orders that were placed before January 1st, 2023: `DELETE FROM orders WHERE order_date < '2023-01-01';`",
                "To remove a specific user from the `users` table: `DELETE FROM users WHERE user_id = 10;`"
              ]
            }
          ],
          "chapterSummary": "Chapter 3 covered the essential commands for Data Manipulation Language (DML). We learned how to add new records to a table using the `INSERT` statement, which can be done by specifying columns and values or by providing values for all columns. We then explored the `UPDATE` statement, which is used to modify existing data, emphasizing the critical importance of the `WHERE` clause to avoid updating all rows. Finally, we learned how to remove data using the `DELETE` statement, again highlighting the necessity of a `WHERE` clause to prevent accidental deletion of all records.",
          "quiz": [
            {
              "question": "Which SQL command is used to add new rows to a table?",
              "type": "one-word",
              "answer": "INSERT"
            },
            {
              "question": "What is the purpose of the `SET` clause in an `UPDATE` statement?",
              "type": "one-word",
              "answer": "Specify new values"
            },
            {
              "question": "Which clause is essential to prevent an `UPDATE` statement from affecting all rows?",
              "type": "one-word",
              "answer": "WHERE"
            },
            {
              "question": "The `INSERT` statement is part of which SQL category?",
              "options": [
                "DQL",
                "DML",
                "DDL",
                "DCL"
              ],
              "type": "mcq",
              "answer": "DML"
            },
            {
              "question": "What happens if you run a `DELETE` statement without a `WHERE` clause?",
              "options": [
                "The query fails",
                "A single row is deleted",
                "All rows in the table are deleted",
                "The table is deleted"
              ],
              "type": "mcq",
              "answer": "All rows in the table are deleted"
            },
            {
              "question": "Which statement is used to modify existing records in a table?",
              "type": "one-word",
              "answer": "UPDATE"
            },
            {
              "question": "What must the number and order of values in an `INSERT` statement match if column names are not specified?",
              "type": "one-word",
              "answer": "Columns"
            },
            {
              "question": "Which command is used to remove rows from a table?",
              "type": "one-word",
              "answer": "DELETE"
            },
            {
              "question": "In an `UPDATE` statement, the `SET` clause is followed by the `UPDATE` keyword. True or False?",
              "options": [
                "True",
                "False"
              ],
              "type": "mcq",
              "answer": "False"
            },
            {
              "question": "What is a common best practice before running a `DELETE` query?",
              "type": "one-word",
              "answer": "Test with SELECT"
            }
          ]
        },
        {
          "chapterNumber": 4,
          "chapterTitle": "Joining Tables",
          "subtopics": [
            {
              "subtopicTitle": "Understanding Joins: `INNER JOIN`",
              "explanation": "In a relational database, data is often spread across multiple tables to avoid redundancy and maintain data integrity. A **join** is a SQL clause used to combine rows from two or more tables based on a related column between them. The most common type of join is the **`INNER JOIN`**. An `INNER JOIN` returns only the rows that have matching values in both tables. This means that if a row in `Table A` does not have a corresponding match in `Table B`, it will not be included in the result set. The syntax for an `INNER JOIN` is `SELECT columns FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name;`. The `ON` clause is crucial, as it specifies the condition on which the tables should be joined. This condition is typically based on the relationship between a primary key in one table and a foreign key in another. For example, if you have an `employees` table with an `employee_id` and a `departments` table with a `department_id`, and `department_id` is a foreign key in the `employees` table, you can join them to get the employee's name and their department's name. An `INNER JOIN` is the go-to join for getting a complete picture of your data when all the pieces are present in both tables. It's a powerful tool for combining disparate but related data and is a fundamental concept for anyone working with relational databases. The result of an `INNER JOIN` is a new, temporary table that combines the columns from the joined tables for all the rows that meet the `ON` condition. The concept of joining tables is what gives relational databases their power and flexibility, allowing complex queries to be built from simple, well-structured tables. ",
              "examples": [
                "To get the name of each employee and the name of their department: `SELECT employees.first_name, departments.department_name FROM employees INNER JOIN departments ON employees.department_id = departments.department_id;`"
              ]
            },
            {
              "subtopicTitle": "Types of Joins: `LEFT`, `RIGHT`, and `FULL`",
              "explanation": "While the `INNER JOIN` is useful for finding matching data, other types of joins are necessary when you want to include non-matching data. The **`LEFT JOIN`** (or `LEFT OUTER JOIN`) returns all rows from the left table and the matched rows from the right table. If there's no match in the right table, the columns from the right table will contain `NULL` values. This is useful when you want to see all the data from one table, even if it doesn't have a related record in the other. For example, you might use a `LEFT JOIN` to list all customers and their orders, including customers who have not placed any orders. The **`RIGHT JOIN`** (or `RIGHT OUTER JOIN`) is the mirror image of the `LEFT JOIN`. It returns all rows from the right table and the matched rows from the left table. If there's no match in the left table, the columns from the left table will contain `NULL` values. The **`FULL JOIN`** (or `FULL OUTER JOIN`) returns all rows from both the left and right tables. It returns matching rows where the `ON` clause is met, and also returns all non-matching rows from both tables, with `NULL` values for the columns from the table that doesn't have a match. `FULL JOIN`s are less common but are useful for finding discrepancies or comparing two datasets where you need to see all records from both. The choice of join type depends entirely on what you're trying to achieve with your query. Understanding the difference between these join types is key to building accurate and comprehensive queries.",
              "examples": [
                "To get a list of all employees and their department, including employees not yet assigned to a department: `SELECT employees.first_name, departments.department_name FROM employees LEFT JOIN departments ON employees.department_id = departments.department_id;`"
              ]
            },
            {
              "subtopicTitle": "Joining Multiple Tables",
              "explanation": "The power of joins is not limited to combining just two tables. You can join three, four, or even more tables in a single query. This is often necessary in a well-normalized database where data is distributed across many tables. The process involves chaining join clauses together. The syntax looks like this: `SELECT columns FROM table1 JOIN table2 ON condition1 JOIN table3 ON condition2;`. The database engine executes these joins sequentially. For example, it would first join `table1` and `table2` based on `condition1`, creating an intermediate result set. Then, it would join this result set with `table3` based on `condition2`. This allows you to combine data from a wide range of tables to answer complex business questions. For instance, you could join a `customers` table, an `orders` table, and a `products` table to find out which customers have purchased which products. The `ON` clauses for each join are crucial and must be correctly defined to link the tables logically. When joining multiple tables, it's also a good practice to use **table aliases** to make the query more readable. An alias is a temporary, shorter name you give to a table within a query. For example, `SELECT c.first_name, o.order_date FROM customers AS c JOIN orders AS o ON c.customer_id = o.customer_id;`. This makes the query easier to read and write. The ability to join multiple tables is a hallmark of a powerful relational database system and is a skill every SQL user must master.",
              "examples": [
                "To find the names of customers who bought a specific product, you would join `customers`, `orders`, and `order_items` tables: `SELECT c.customer_name, p.product_name FROM customers AS c JOIN orders AS o ON c.customer_id = o.customer_id JOIN order_items AS oi ON o.order_id = oi.order_id JOIN products AS p ON oi.product_id = p.product_id WHERE p.product_name = 'Laptop';`"
              ]
            }
          ],
          "chapterSummary": "Chapter 4 delved into the crucial concept of joining tables to combine data. We started with the `INNER JOIN`, which returns only the rows with matching values in both tables. We then explored other join types: `LEFT JOIN` to get all rows from the left table, `RIGHT JOIN` to get all rows from the right, and `FULL JOIN` to get all rows from both. Finally, we learned how to chain multiple joins together to combine data from more than two tables, using table aliases for clarity, a key skill for working with complex, normalized databases.",
          "quiz": [
            {
              "question": "What is the most common type of join that returns only matching rows?",
              "type": "one-word",
              "answer": "INNER JOIN"
            },
            {
              "question": "Which clause is used to specify the join condition?",
              "type": "one-word",
              "answer": "ON"
            },
            {
              "question": "A `LEFT JOIN` returns all rows from which table?",
              "type": "one-word",
              "answer": "Left"
            },
            {
              "question": "Which of the following joins returns all rows from both tables, with NULLs where there is no match?",
              "options": [
                "INNER JOIN",
                "LEFT JOIN",
                "RIGHT JOIN",
                "FULL JOIN"
              ],
              "type": "mcq",
              "answer": "FULL JOIN"
            },
            {
              "question": "A foreign key in one table links to what type of key in another table?",
              "options": [
                "Foreign Key",
                "Unique Key",
                "Primary Key",
                "Composite Key"
              ],
              "type": "mcq",
              "answer": "Primary Key"
            },
            {
              "question": "What is a temporary, shorter name for a table in a query called?",
              "type": "one-word",
              "answer": "Alias"
            },
            {
              "question": "To get all rows from the `employees` table and matching rows from the `departments` table, you would use a _________ join.",
              "type": "one-word",
              "answer": "LEFT"
            },
            {
              "question": "Can you join more than two tables in a single query?",
              "type": "one-word",
              "answer": "Yes"
            },
            {
              "question": "If a row in the left table of a `LEFT JOIN` has no match in the right table, what value will the right table's columns have in the result?",
              "type": "one-word",
              "answer": "NULL"
            },
            {
              "question": "The `ON` clause in a join is used to specify the join condition. True or False?",
              "options": [
                "True",
                "False"
              ],
              "type": "mcq",
              "answer": "True"
            }
          ]
        },
        {
          "chapterNumber": 5,
          "chapterTitle": "Aggregate Functions and Grouping",
          "subtopics": [
            {
              "subtopicTitle": "Aggregate Functions: `COUNT`, `SUM`, `AVG`, `MIN`, and `MAX`",
              "explanation": "**Aggregate functions** are used in SQL to perform a calculation on a set of values and return a single value. These are extremely useful for data analysis and reporting. The most common aggregate functions are `COUNT`, `SUM`, `AVG`, `MIN`, and `MAX`. The **`COUNT()`** function counts the number of rows in a result set. For example, `SELECT COUNT(*) FROM employees;` will return the total number of employees. The **`SUM()`** function calculates the sum of a set of numeric values. `SELECT SUM(salary) FROM employees;` would return the total payroll. The **`AVG()`** function calculates the average of a set of numeric values. `SELECT AVG(price) FROM products;` will give you the average price of all products. The **`MIN()`** and **`MAX()`** functions are used to find the smallest and largest values in a column, respectively. `SELECT MIN(hire_date) FROM employees;` would return the hire date of the oldest employee. Aggregate functions ignore `NULL` values by default, except for `COUNT(*)` which counts all rows including those with `NULL`s. You can also use the `DISTINCT` keyword with an aggregate function to perform the calculation on only the unique values in a column, like `COUNT(DISTINCT city)`. Aggregate functions are an essential part of SQL, allowing you to transform raw data into meaningful insights and summaries. They are often used in conjunction with the `GROUP BY` clause, which we'll discuss next, to perform these calculations on subsets of data. ",
              "examples": [
                "To find the highest salary in the company: `SELECT MAX(salary) FROM employees;`",
                "To count the number of products in the 'Electronics' category: `SELECT COUNT(*) FROM products WHERE category = 'Electronics';`"
              ]
            },
            {
              "subtopicTitle": "Grouping Data with `GROUP BY`",
              "explanation": "The **`GROUP BY` clause** is used in conjunction with aggregate functions to group rows that have the same values into summary rows. This allows you to perform calculations on a per-group basis. For example, instead of getting the total sales for the entire company, you could use `GROUP BY` to get the total sales for each product category. The syntax is `SELECT column1, aggregate_function(column2) FROM table_name GROUP BY column1;`. The `SELECT` clause must contain either an aggregate function or a column that is also in the `GROUP BY` clause. This is a fundamental rule of SQL. For instance, `SELECT department_id, AVG(salary) FROM employees GROUP BY department_id;` would return the average salary for each unique department. Without the `GROUP BY` clause, the `AVG()` function would return a single value representing the average salary for all employees. The `GROUP BY` clause can also group by multiple columns, creating more granular groups. For example, `GROUP BY year, month` would group data by each unique year-month combination. The `GROUP BY` clause is a cornerstone of data analysis in SQL, enabling you to break down data into meaningful segments and summarize information from a large dataset. It is a powerful tool for generating reports and getting insights that are not possible with simple queries.",
              "examples": [
                "To count the number of employees in each department: `SELECT department_id, COUNT(employee_id) FROM employees GROUP BY department_id;`",
                "To find the total sales for each salesperson: `SELECT salesperson_id, SUM(total_price) FROM sales GROUP BY salesperson_id;`"
              ]
            },
            {
              "subtopicTitle": "Filtering Grouped Data with `HAVING`",
              "explanation": "While the `WHERE` clause is used to filter individual rows before they are grouped, the **`HAVING` clause** is used to filter the groups themselves after they have been created by the `GROUP BY` clause. This is a critical distinction. You cannot use aggregate functions in a `WHERE` clause because `WHERE` evaluates rows before the aggregation occurs. The `HAVING` clause, on the other hand, operates on the result of the `GROUP BY` and the aggregate functions. The syntax is `SELECT column1, aggregate_function(column2) FROM table_name GROUP BY column1 HAVING condition;`. The `condition` in the `HAVING` clause typically involves an aggregate function. For example, to find departments where the average salary is greater than $60,000, you would write `SELECT department_id, AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) > 60000;`. You can also combine `HAVING` with `WHERE`. The `WHERE` clause would filter rows first, then the remaining rows would be grouped, and finally, the `HAVING` clause would filter the resulting groups. For example, to find departments with more than 10 employees, but only for employees hired after 2020: `SELECT department_id, COUNT(*) FROM employees WHERE hire_date > '2020-01-01' GROUP BY department_id HAVING COUNT(*) > 10;`. The `HAVING` clause is a powerful tool for performing conditional filtering on aggregated data, making it an indispensable part of advanced SQL reporting and analysis.",
              "examples": [
                "To find all product categories with a total stock of less than 100 units: `SELECT category, SUM(stock_quantity) FROM products GROUP BY category HAVING SUM(stock_quantity) < 100;`"
              ]
            }
          ],
          "chapterSummary": "Chapter 5 introduced aggregate functions and grouping, key tools for data analysis. We first learned about aggregate functions like `COUNT`, `SUM`, `AVG`, `MIN`, and `MAX`, which perform calculations on sets of data to return a single value. We then explored the `GROUP BY` clause, which groups rows with similar values, allowing aggregate functions to operate on these distinct groups. Finally, we learned how to filter these groups using the `HAVING` clause, which is used specifically for applying conditions to the results of aggregate functions, a crucial step for advanced data filtering.",
          "quiz": [
            {
              "question": "Which aggregate function is used to find the average value of a column?",
              "type": "one-word",
              "answer": "AVG"
            },
            {
              "question": "The `COUNT(*)` function is used to count what?",
              "type": "one-word",
              "answer": "Rows"
            },
            {
              "question": "Which clause is used to group rows with similar values?",
              "type": "one-word",
              "answer": "GROUP BY"
            },
            {
              "question": "Which of the following functions returns the smallest value in a column?",
              "options": [
                "SUM",
                "AVG",
                "MIN",
                "MAX"
              ],
              "type": "mcq",
              "answer": "MIN"
            },
            {
              "question": "Which clause is used to filter groups created by `GROUP BY`?",
              "options": [
                "WHERE",
                "HAVING",
                "FILTER",
                "LIMIT"
              ],
              "type": "mcq",
              "answer": "HAVING"
            },
            {
              "question": "Can you use aggregate functions in a `WHERE` clause?",
              "type": "one-word",
              "answer": "No"
            },
            {
              "question": "What happens to `NULL` values when using `SUM()`?",
              "type": "one-word",
              "answer": "Ignored"
            },
            {
              "question": "Which function would you use to get the total number of units sold?",
              "type": "one-word",
              "answer": "SUM"
            },
            {
              "question": "The `HAVING` clause is applied before the `GROUP BY` clause. True or False?",
              "options": [
                "True",
                "False"
              ],
              "type": "mcq",
              "answer": "False"
            },
            {
              "question": "What keyword is used with an aggregate function to only consider unique values?",
              "type": "one-word",
              "answer": "DISTINCT"
            }
          ]
        }
      ]
    }
    ]}